# Not Only Bitcoin Tips - Cursor AI Rules & Project Context

## PROJECT OVERVIEW
This is a decentralized crowdfunding DApp built on Internet Computer Protocol (ICP) that allows users to create fundraising campaigns with unique wallet addresses for donations. Each campaign generates a cryptographically secure account ID based on user principal and campaign ID.

## TECH STACK & ARCHITECTURE

### Backend (Internet Computer)
- **Language**: Motoko
- **Framework**: Internet Computer (IC) with DFX 0.28.0
- **Authentication**: Internet Identity
- **Storage**: Enhanced orthogonal persistence
- **Key Canister**: `user_canister` (backend/user_canister.mo)

### Frontend
- **Framework**: React 19.1.0 + TypeScript + Vite 7.0.4
- **Styling**: Tailwind CSS 4.1.11
- **Routing**: React Router Dom 7.7.1
- **IC Integration**: @dfinity/agent 3.1.0, @dfinity/auth-client 3.1.0
- **QR Codes**: qrcode.react 4.2.0

### Key Files & Structure
```
/backend/user_canister.mo    # Main Motoko canister with wallet system
/frontend/src/
  ├── App.tsx               # Router setup (/, /donate/:id)
  ├── MainApp.tsx           # Main app with auth & campaign creation
  ├── CampaignPage.tsx      # Individual campaign pages
  ├── account.ts            # Account ID generation (ICP standard)
  ├── ledger.ts             # ICP Ledger integration
  └── canisters/            # Canister type definitions
```

## CORE FUNCTIONALITY

### 1. Wallet System Architecture
**Each campaign has a unique ICP account ID generated as:**
```
account_id = CRC32(h) || h
where h = SHA224("\x0Aaccount-id" || user_principal || campaign_subaccount)
```

- **Frontend**: `account.ts` - Standards-compliant ICP account generation
- **Backend**: `generateAccountId()` function in user_canister.mo
- **Purpose**: Each campaign gets its own wallet for receiving ICP donations

### 2. Campaign Lifecycle
1. **Authentication**: Internet Identity login → Principal ID
2. **User Registration**: `createUser(name, email?)` 
3. **Campaign Creation**: `createCampaign(name, description, acceptedTokens[])`
4. **Account Generation**: Automatic unique account ID creation
5. **Donations**: Direct ICP transfers to campaign account
6. **Balance Tracking**: Real-time balance updates every 10 seconds
7. **Withdrawal**: Campaign owners can withdraw to personal wallets

### 3. Data Types (Motoko)
```motoko
type User = {
    id: UserId;           // Principal
    name: Text;
    email: ?Text;
    createdAt: Nat64;
};

type Campaign = {
    id: CampaignId;       // Text
    name: Text;
    description: Text;
    owner: UserId;        // Principal
    acceptedTokens: [Text];
    subaccount: Blob;     // 32-byte campaign identifier
    accountId: AccountId; // Generated ICP account
    createdAt: Nat64;
};
```

## DEVELOPMENT RULES & CONVENTIONS

### Motoko Backend Rules
1. **Use stable storage** for all persistent data (users, campaigns)
2. **Validate caller identity** for all update operations
3. **Error handling**: Use Result<T, Text> for operations that can fail
4. **Account ID generation**: Always use cryptographically secure methods
5. **Query vs Update**: Balance checks are queries, withdrawals are updates

### TypeScript/React Frontend Rules
1. **Strict TypeScript**: Enable all strict checks
2. **React 19 patterns**: Use modern hooks, avoid class components
3. **Async/await**: For all IC canister calls
4. **Error boundaries**: Wrap IC operations in try-catch
5. **Type safety**: Import proper types from declarations/

### ICP Integration Rules
1. **Environment handling**: Support local (localhost:4943) and mainnet (ic0.app)
2. **Identity management**: Always check authentication state
3. **Canister calls**: Use proper agent configuration
4. **Account IDs**: Always validate format before blockchain operations
5. **Gas fees**: Consider cycle costs for operations

## CRITICAL IMPLEMENTATION DETAILS

### Account ID Generation (Frontend)
```typescript
// Standards-compliant ICP account generation
export async function generateAccountId(userPrincipal: string, campaignId: string): Promise<string> {
  const principal = Principal.fromText(userPrincipal);
  const campaignBytes = new TextEncoder().encode(campaignId);
  const subaccount = new Uint8Array(32);
  // Copy campaign ID into 32-byte subaccount...
  return await generateAccountIdentifier(principal, subaccount);
}
```

### Balance Tracking Strategy
- **Query calls**: Frontend polls balance every 10 seconds
- **Update calls**: Only for withdrawals (expensive)
- **Error handling**: Graceful fallback to 0 balance on errors

### Security Considerations
1. **Principal validation**: Always verify caller identity
2. **Campaign ownership**: Only owners can withdraw funds
3. **Input sanitization**: Validate all user inputs
4. **Rate limiting**: Consider implementing for balance queries

## ENVIRONMENT SETUP

### Local Development
```bash
dfx start --clean --background
dfx deploy
cd frontend && npm install && npm run dev
```

### Environment Variables (frontend/.env)
```
VITE_CANISTER_ID_USER_CANISTER=$(dfx canister id user_canister)
VITE_CANISTER_ID_INTERNET_IDENTITY=$(dfx canister id internet_identity)
VITE_CANISTER_HOST=http://127.0.0.1:4943  # or https://ic0.app for mainnet
DFX_NETWORK=local  # or ic for mainnet
VITE_DFX_NETWORK=local  # or ic for mainnet
```

## TESTING STRATEGY
- **Candid UI**: http://127.0.0.1:4943/?canisterId=umunu-kh777-77774-qaaca-cai&id=uzt4z-lp777-77774-qaabq-cai
- **Internet Identity**: Local testing with temporary identities
- **Account generation**: Verify hex format and uniqueness
- **Balance simulation**: Use getRealAccountBalance vs getSimulatedBalance

## DEPLOYMENT
- **Local**: `dfx deploy`
- **Mainnet**: `dfx deploy --network ic` (requires cycles)
- **Scripts**: Use scripts/deploy-to-mainnet.sh for production

## CODING STYLE PREFERENCES
1. **Ukrainian comments**: Code comments in Ukrainian language
2. **Descriptive naming**: Long, clear variable names over short ones
3. **Error messages**: Informative error handling with context
4. **Console logging**: Extensive logging for debugging
5. **Type annotations**: Explicit types even when inferred

## COMMON PATTERNS TO FOLLOW

### Canister Integration
```typescript
import { user_canister } from './canisters';
const actor = user_canister;
const result = await actor.createCampaign(name, description, tokens);
```

### Balance Updates
```typescript
useEffect(() => {
  const interval = setInterval(async () => {
    const balance = await getAccountBalance(accountId);
    setBalance(balance);
  }, 10000);
  return () => clearInterval(interval);
}, [accountId]);
```

### Error Handling
```typescript
try {
  const result = await actor.someOperation();
  if ('Err' in result) {
    console.error('Operation failed:', result.Err);
    return;
  }
  // Handle success case
} catch (error) {
  console.error('Network error:', error);
}
```

## PERFORMANCE CONSIDERATIONS
1. **Query calls**: Prefer query over update for read operations
2. **Batch updates**: Group related operations when possible
3. **Caching**: Cache campaign data and balance info appropriately
4. **Bundle size**: Monitor frontend bundle size with Vite analyzer

## FUTURE ROADMAP
- Real ICP Ledger integration (currently simulated)
- Multi-token support (BTC, ETH, USDT)
- Campaign analytics and statistics
- Email/SMS notifications for donations
- Public API for balance verification
- Mobile responsive improvements

This is a hackathon project built for ICP ecosystem, prioritizing rapid development while maintaining security and proper IC integration patterns. 