# План: посилання на NNS для донату, політика видалення кампаній, мультивалюта (ICP → BTC/ETH/USDT)

Нижче — детальний, поетапний план реалізації. Код не змінюємо; лише фіксуємо узгоджений дизайн та кроки впровадження.

## 1) Додати можливість поповнити кампанію зі свого гаманця прямо в dApp - має працювати для всіх користувачів - донаторів і автора

### Висновки з дослідження
  - «Open on Dashboard»: посилання `https://dashboard.internetcomputer.org/account/<accountId>` — показує деталізацію акаунта (для валідації адреси), але не ініціює переказ.
  - «One‑click transfer з DApp»: підписати виклик до ICP Ledger напряму через II користувача (без відкриття NNS). Це технічно можливо: фронтенд створює `HttpAgent` з II identity та викликає `ledger.account_balance_dfx`/`ledger.transfer` від імені користувача. Переказ виконується з його основного (або обраного) субакаунта.

### Запропонований UX‑flow (поетапно)
- Додати опцію «Send directly with II» (альтернатива відкриттю NNS) — вбудована форма: сума (ICP), опціональний memo, кнопка «Send». Під капотом — виклик ICP Ledger через `@dfinity/agent`, підписаний II користувача. 
- Валідувати баланс перед відправкою, показувати очікувану комісію (0.0001 ICP).


### Безпека, валідації, UX‑деталі
- Показувати checksum‑перевірку адреси (hex/довжина) перед копіюванням/відправкою.
- Відображати попередження про мережу (local/mainnet) та Canister host у DEV логах, але без шуму в PROD.
- Анти‑дублікати кліків: блокувати кнопку під час відправки; idempotent UI (toast + tx hash/height).
- Логи помилок з friendly повідомленнями (мережеві помилки, недостатній баланс, невірна адреса).

### Тестування
- Локально: мок Ledger (вже є `account_balance_dfx`) + e2e: копіювання адреси, відкриття NNS/Dashboard, формат QR.
- На mainnet: тестовий переказ з малого балансу на донат‑адресу; перевірка появи транзакції у Dashboard, правильності відображення балансу в DApp.

---

## 2) Політика видалення кампаній

### Бізнес‑правила
- Кампанії НЕ можна видаляти, якщо баланс > 0 (є токени/депозити) — щоб не «зникали кошти/історія».
- Видалення — лише власником (owner), після повного обнулення всіх прийнятих активів.
- Для звичайних користувачів кнопки «Delete» у UI не повинно бути взагалі.

### План змін (backend/UX/правила)
- Backend (коли з’явиться `deleteCampaign`):
  - Перевірка `caller == owner`.
  - Перевірка на нульові баланси по всіх активних токенах кампанії (ICP/ICRC‑1 тощо).
  - М’яке видалення (soft‑delete) або архівація з футпрінтом події (audit trail).
- Frontend:
  - Прибрати кнопку «Delete» у списку та на сторінці кампанії.
  - Якщо колись додамо — відображати лише власнику і тільки коли всі баланси == 0 (і валідацію повторювати на бекенді).
- Тести:
  - E2E: власник із нульовими балансами → видалення успішне; не власник → 403; ненульові баланси → 400.

---

## 3) Мультивалюта через ck‑обгортки (ckBTC, ckETH, ckUSDT) — без нативних мереж

### Модель і UX для користувача
- Донат відбувається у нативній мережі відповідного активу на депозитну адресу мінтера (L1):
  - BTC → депозитна BTC‑адреса мінтера ckBTC
  - ETH → депозитна Ethereum‑адреса мінтера ckETH
  - USDT → депозитна адреса мінтера ckUSDT (ERC‑20), якщо доступний
- Після N підтверджень на L1 мінтер нараховує відповідні ck‑токени на ICRC‑рахунок кампанії (на ICP). Баланс з’являється у DApp.
- Виведення: власник вказує зовнішню L1‑адресу (BTC/ETH/USDT ERC‑20), ми викликаємо `withdraw` у мінтера; ck‑токени спалюються, мінтер надсилає нативні кошти на L1‑адресу. Показуємо комісії/ETA.

### Важливі обмеження
- Не можна відправляти нативні монети напряму на ICRC/ICP accountId кампанії — лише на депозитні адреси мінтерів.
- У Binance/бірж обовʼязково вибирати правильну мережу в «Withdraw». Неправильна мережа = втрата коштів.
- Наявність певних ck‑токенів (особливо ckUSDT) залежить від мережевої доступності/деплою мінтера. Якщо токен недоступний, ми ховаємо його з UI.

### Roadmap поетапно (одна валюта за раз)
1) Фаза A — ckBTC (починаємо з нього; найстабільніший шлях)
- Інтеграції:
  - Читання ICRC‑балансу кампанії: `icrc1_balance_of` для `ckBTC` ledger.
  - Отримання депозитної адреси BTC від мінтера (endpoint/actor мінтера ckBTC).
- Frontend:
  - Відображення токена ckBTC у кампанії: баланс, QR депозитної BTC‑адреси, інструкції по мережі/підтвердженнях.
  - Полінг статусу депозиту (pending → credited) з friendly статусами.
  - Виведення: форма withdraw (L1 BTC адреса) + оцінка fee/часу.
- Backend:
  - Зберігати активовані токени кампанії; лог подій (donation credited/withdrawn) для аудиту.
- Тести:
  - Невеликий депозит із біржі на депозитну адресу → поява ckBTC на балансі кампанії; withdraw на зовнішню BTC‑адресу.

2) Фаза B — ckETH
- Аналогічно ckBTC, але для Ethereum (мережеві відмінності: gas/час підтверджень).
- Додатково: нотифікації про комісії L1, попередження щодо мережі (Ethereum mainnet).

3) Фаза C — ckUSDT (ERC‑20) — лише якщо мінтер доступний
- Вмикаємо після підтвердження доступності ckUSDT у мережі.
- UI/логіка ідентичні: депозитна ERC‑20 адреса від мінтера, баланс ICRC, withdraw на L1 ERC‑20 адресу.

### Крос‑токенова модель у фронті
- Єдиний компонент TokenRow з контрактним інтерфейсом:
  - `symbol`, `decimals`, `getBalance()`, `getDepositAddress()`, `explorerLink`, `withdraw(...)`.
- Політика відображення: показувати лише активовані токени кампанії.
- Кешування балансів (10–30 сек), оновлення без «миготіння».

### Безпека й валідації
- Попередження про мережу/комісії перед депозитом/виведенням.
- Валідація форматів L1‑адрес (BTC bech32/legacy, ETH/ERC‑20 checksum).
- Ризики: затримки підтверджень, тимчасова недоступність мінтера → дружні стани «pending/queued». 

### Тест‑план
- Юніт: перетворення форматів адрес/балансів, станова машина статусів депозиту.
- Інтеграційні: депозит невеликої суми на адресу мінтера → зарахування ck‑балансу; withdraw на L1‑адресу з урахуванням fee.
- E2E: UX потік по кожному токену: обрати токен → отримати депозитну адресу → здійснити депозит → побачити баланс → зробити withdraw.

---

## 4) Тестування та автоматизація (Playwright + API tests + CI/hooks)
- E2E (Playwright, локальна мережа, ICP‑only на старті):
  - Запуск dev‑сервера автівно через `webServer` у `playwright.config.ts`.
  - `storageState` для Internet Identity (одноразовий логін, збереження сесії) — додати після базових тестів.
  - Базові тести: smoke (title, версія), неавтентифікований вигляд, створення кампанії (UI валідації), умовний рендер ckBTC секції.
- API tests (unit/integration для `user_canister`):
  - Endpoints: `whoami`, `createUser`, `userExists`, `createCampaign`, `getUserCampaigns`, `getCampaign`, `getCampaignAccountId`, `getCampaignSubaccount`, `deleteCampaign`, `withdrawFunds`.
  - Сценарії: авторизація → створення юзера → створення кампанії → перевірки атрибутів; видалення (власник/не власник; баланс 0/не 0 — коли зʼявиться перевірка); умовний рендер токенів.
  - Технічно: Node‑тести з `@dfinity/agent` або `dfx canister call` в `tests/api`, із моками там, де потрібні зовнішні сервіси.
- Автоматизація запуску:
  - Локально: `npm run test:e2e` (frontend).
  - Git hooks/CI: додати pre‑push або CI job, що виконує build + e2e + API tests (без взаємодії з mainnet).

---

## Організаційні домовленості
- Документація/правила додані в `.cursorrules` після релізу.
- Теги (`vX.Y.Z`) створюються ЛИШЕ за явною командою користувача; релізні точки позначаємо також `release/`‑гілками при потребі.

## Готовність до реалізації
- Етап А (NNS Open + буфер) і видалення кнопки — 0.5–1 роб. дня.
- ckBTC інтеграція (баланс+депозитна адреса+UI+withdraw) — 1–2 роб. дні.
- «Send directly with II» (ICP) — 1–2 роб. дні з ретельним UX.
- Далі: ckETH → ckUSDT (за доступності). 